Overview
The tcp-hole-punch-clean branch wires an opt-in libp2p/DCUtR adapter beside the existing TCP transport. When libp2p is enabled, a SwarmStreamProvider drives libp2p dial/listen/reservation logic and bridges negotiated substreams into the Kaspa ConnectionHandler via connect_with_stream/serve_with_incoming. By default libp2p is off; the main TCP listener and handshake remain unchanged. In libp2p-mode=full the outbound connector uses libp2p exclusively, which currently strands a node on mainnet because peers are TCP-only.

Modes & Config Surface
- Flags live in `kaspad/src/args.rs` and map into `Libp2pArgs` (`kaspad/src/libp2p.rs`): `--libp2p-mode` (off/full/helper alias), `--libp2p-identity-path`, `--libp2p-helper-listen`, `--libp2p-listen-port`, `--libp2p-relay-inbound-cap`, `--libp2p-relay-inbound-unknown-cap`, `--libp2p-reservations`, `--libp2p-external-multiaddrs`, `--libp2p-advertise-addresses`, `--libp2p-autonat-allow-private`. Defaults: mode off, ephemeral identity, helper disabled, listen port = p2p port + 1.
- `libp2p_config_from_args` (`kaspad/src/libp2p.rs`) merges CLI/env, resolves identity path, builds `AdapterConfig` (ports, helper bind, reservations, external/advertise addrs, AutoNAT policy). Env vars override when CLI not set (e.g., `KASPAD_LIBP2P_MODE`, `*_LISTEN_PORT`, `*_RESERVATIONS`).
- Runtime wiring (`kaspad/src/libp2p.rs` + `kaspad/src/daemon.rs`): `libp2p_runtime_from_config` builds a `Libp2pOutboundConnector` (fallback TCP when mode off; otherwise libp2p provider cell) and optionally a `Libp2pInitService` to start the swarm. `daemon.rs` hands that outbound connector to FlowContext/P2pService and registers the init + node services.
- Mode semantics: Off => outbound connector is plain TCP; no libp2p services advertised. Full/Helper => advertised service bit set, helper listen port propagated, AutoNAT toggle applied, outbound connector expects a libp2p provider (no TCP fallback when enabled). Helper currently aliases Full; there is no narrow helper-only runtime.
- libp2p-mode=full behavioural impact: ConnectionManager still runs but its outbound connector calls into libp2p dial; there is no TCP attempt. The TCP server still listens (P2pService is bidirectional unless inbound_limit=0), so inbound TCP remains available.

NetAddress & Metadata
- NetAddress (`utils/src/networking.rs`) stores `ip`, `port`, `services: u64`, and optional `relay_port`. Equality/hash are ip+port only. `merge_metadata` ORs services and overwrites relay_port if the new address carries one; used when the same endpoint is re-seen with extra capabilities.
- Service flag `NET_ADDRESS_SERVICE_LIBP2P_RELAY` marks a peer as a libp2p relay candidate; daemon sets this for local node when mode is enabled (`kaspad/src/daemon.rs`), and FlowContext includes it in the version handshake (`protocol/flows/src/flow_context.rs`) along with `relay_port` derived from `--libp2p-helper-listen`.
- AddressManager stores/merges the flag/relay_port on add (`components/addressmanager/src/lib.rs::add_address` uses `merge_metadata`). A node learns a peer is libp2p-capable only if that peer advertised the service bit (and optional relay_port) in its Version address; the AddressManager itself does not infer libp2p from dial success or other metadata.

Libp2p Adapter (components/p2p-libp2p)
- Swarm ownership: `SwarmStreamProvider` (`transport.rs`) builds the libp2p swarm with DCUtR/relay/identify/autonat behaviours (`swarm.rs`) and runs `SwarmDriver` in a task. `Libp2pService` (`service.rs`) owns the provider, reservations worker, and helper listener; `Libp2pNodeService` in `kaspad/src/libp2p.rs` starts `Libp2pService` and the inbound bridge once the provider and ConnectionHandler are ready.
- Dial lifecycle: connection requests become `SwarmCommand::Dial`; the driver records a `DialRequest {respond_to, started_at, via}` keyed by the libp2p `StreamRequestId`. Relay dials set `via=Relay{target_peer}`; direct dials use `Direct`. Pending entries clear on successful outbound stream (`StreamEvent::Outbound`), on `OutgoingConnectionError`, `ConnectionClosed`, timeout expiry (30s via periodic `expire_pending_dials`), and on shutdown (drain sends DialFailed). DCUtR handoff: when a direct connection establishes after relay dials, `take_pending_relay_by_peer` moves the oldest relay pending for that peer onto the new connection_id so the eventual stream resolves the original request.
- DCUtR integration: Identify `Received` events add observed/listen addresses to the swarm’s external set (ignoring relay addrs) and mark dcutr support. `DcutrBootstrapBehaviour` seeds external-address candidates (from `external_multiaddrs` and `advertise_addresses`) into DCUtR before the swarm runs and replays `ExternalAddrConfirmed` events as `NewExternalAddrCandidate` so DCUtR sees them. `maybe_request_dialback` triggers a relay dial-back when connected via relay, peer supports dcutr, and we have no outgoing connection, with a 30s per-peer cooldown; it uses the active relay derived from reservations or listen addrs.
- Helper API: `HelperApi` (`helper_api.rs`) accepts JSON `{ "action": "status" }` or `{ "action": "dial", "multiaddr": "<...>" }`. `handle_helper_connection` (`service.rs`) enforces max line 8KiB, 5s read timeout, one command per TCP connection; invalid UTF-8/JSON or unknown actions yield JSON `{ok:false,...}` and are logged. Dial errors are surfaced as `DialFailed`.
- Reservations & limits: `reservation_worker` refreshes configured multiaddrs on a 30s poll with a 20m refresh horizon. `ReservationManager` (`reservations.rs`) tracks per-key exponential backoff; on refresh, existing handles are released before storing new ones. Shutdown releases all handles. The driver tracks active reservation listeners to remove them on shutdown.
- Backpressure: libp2p incoming streams feed a bounded channel of 32 (`INCOMING_CHANNEL_BOUND`); `enqueue_incoming` drops with a single warn on full/closed. The bridge to ConnectionHandler uses another bounded channel of 8 (`service.rs`) for inbound streams handed to `serve_with_incoming`.
- Stream→Kaspa bridge: `Libp2pService::start_inbound` listens via provider; outbound-direction streams call `ConnectionHandler::connect_with_stream` immediately. Inbound-direction streams are wrapped in `MetadataConnectInfo` (socket_addr None, libp2p metadata preserved) and fed to `serve_with_incoming`, which exposes the metadata to tonic via Connected. `metadata_from_endpoint` (`transport.rs`) derives `TransportMetadata` (libp2p=true, peer_id, path=Direct or Relay{relay_id}, reported_ip from multiaddr). Synthetic IPv6 addresses can be derived later via `TransportMetadata::synthetic_socket_addr` (`protocol/p2p/src/transport.rs`) for accounting.

Connection Manager & Dial Policy
- Outbound selection: `ConnectionManager::handle_outbound_connections` (`components/connectionmanager/src/lib.rs`) pulls weighted random NetAddresses from AddressManager, ignoring service bits/path; it attempts to satisfy `outbound_target` by calling `Adaptor::connect_peer` with the socket string. Failures mark connection_failed_count; successes reset it.
- Transport wiring: The Adaptor’s `ConnectionHandler` uses the outbound connector supplied by daemon’s `libp2p_runtime_from_config`. In libp2p-mode=off the connector is `TcpConnector`. In libp2p-mode=full/helper the connector is `Libp2pOutboundConnector` with no TCP fallback once enabled; it parses the address into `NetAddress`, calls `provider.dial` (libp2p swarm), sets `capabilities.libp2p=true`, and hands the stream to `connect_with_stream`. If the provider cell is unset, it returns an error; if the libp2p dial fails, the TCP path is not retried.
- Inbound limits/buckets: `handle_inbound_connections` classifies peers as libp2p if `metadata.capabilities.libp2p` or `path` is Relay (`PathKind::Relay`). It enforces per-relay caps (`relay_overflow`, unknown bucket vs per-id) then a libp2p half-budget (`inbound_limit/2`, min 1), then total inbound cap, dropping random peers beyond limits. Relay caps default to 4 per known relay and 8 for unknown unless overridden by CLI.
- Why libp2p-mode=full yields 0/8 on mainnet: DNS-seeded addresses are plain TCP peers. The ConnectionManager selects them as usual, but the outbound connector (Libp2pOutboundConnector) attempts libp2p dials to `/ipX/tcp/port` for those peers. Mainnet nodes neither run libp2p nor listen on the libp2p protocol at 16111, so the swarm dial fails; errors are marked as connection failures, no TCP retry occurs, and the loop repeats, leaving `0/8 outgoing` as observed in `MAINNET-SOAK-REPORT.md`. Inbound TCP remains open but does not fill the outbound target.

NAT Lab Behaviour vs Code
- The Proxmox lab commands match the code paths: helper listener gated by `--libp2p-helper-listen`, reservations via `--libp2p-reservations`, external addresses via `--libp2p-external-multiaddrs`, AutoNAT private allowance via `--libp2p-autonat-allow-private`. DCUtR relies on external addresses being seeded (Identify and DcutrBootstrap). Misconfig cases from the stress report map to code paths: missing external addrs -> DCUtR `NoAddresses` (Identify sees none), wrong addrs -> bounded `AttemptsExceeded(3)` retries. Backpressure tests align with bounded helper/read limits and incoming channel drops. Reservation refresh/backoff and helper error recovery in the report are implemented in `service.rs`/`reservations.rs`.
